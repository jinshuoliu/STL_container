# 大致脉络

```txt
这一系列主要讲的就是常用的容器，其中会在ReadMe中讲解我了解到的一些知识，会在0x-stl.cpp中记录侯捷老师讲解的关于各个容器的源代码。
  01-list.cpp:list容器的讲解源码。
  02-vector.cpp:vector容器的讲解源码。
  03-array.cpp:array容器的讲解源码。
  04-deque.cpp:deque容器的讲解源码。

```

**关于容器的核心精彩的部分是扩充容量：**
理解这里会很清楚的理解这个容器的内涵

## 1. 序列式容器

- 序列式容器：其中的元素都是可序的。

**G2.9与G4.9：**

- 大多数的代码都是G2.9版本的
- G2.9的可读性明显的高于G4.9
- G4.9为了使它的框架更大，使G2.9一个类可以完成的事情分成了多个类来完成
  - 它通常设计成了：本体-继承->base-组合->impl-继承->std::allocator
- 但是G4.9虽然扩充了很多，但是功能还是很少的，并没有为它添加很多的功能，显得代码臃肿

### 1.1. list

**注意：**

- 关于list的大小：T+两个指针大小
- iterator设计成了一个类：这是因为list不是连续的空间，如果就是简单的设计成了指针，那么会指向错误的空间
- list本身和list的节点是不同结构的，需要分开设计。
- 由于STL list是一个双向链表，迭代器必须具备前移、后移的能力，所以list提供的是Bidirectional iterators

**list的数据结构：**
由于要符合它的范围是前闭后开的原则，所以要在换装链表的尾端加上一个空白节点。

**list_iterator:**

- 可以在使用迭代器的时候进行插入和删除操作。
- 删除也只有 "被删除的那个元素" 的迭代器失效（这个怎么说呢？一个list应该只有一个迭代器的，他应该是想说被删元素就无法迭代它了）
- 关于++、--操作：
  - 迭代器有个node指针，指向当前的节点
  - 当进行++、--操作的时候就是给node指针赋予当前节点的上一个/下一个节点的指针
  - 相对于vector的迭代器简单的指针指向空间，这两个大同小异的，都是指针指向节点然后向前向后走罢了，只不过vector空间连续所以简单了而已。

### 1.2. vector

**注意：**

- 简单理解的话就把它当作数组
- 它可以动态扩充
- 它就像一个数组，它的内存扩充是二倍扩充
  - 当容量不够时就另寻一个空间，然后将数据移动过去。
- 它的关键在于对其大小的控制以级重新配置时的数据移动效率。
- 它是在一块内存空间上的，所以对数据的访问会快一些，但是插入和删除一些数据会变得慢些

### 1.3. array  

它就是个简单的连续空间存储数据，定义时就固定了大小。

### 1.4. deque

分段连续，它的如何实现伪连续很有意思。

**deque和vector的差异：**

1. deque允许对头端元素进行插入和移除操作
2. deque没有容量的观念，因为它是动态的以连续空间组成的
3. 它的迭代器很复杂
4. 所以：尽量选择vector

#### 1.4.1. deque的中控器

- deque的最大任务就是维护它整体连续的假象
- deque采用一块map作为中控：
  - 它是一块连续的小块空间
  - 每个元素(节点)都是指针，指向另一段比较大的连续线性空间(缓冲区)那才是deque的主要存储的空间
  - 允许自己指定空间的大小，默认0为512bytes

#### 1.4.2. deque的迭代器

- 为了维护deque整体连续的假象，它的operator++、operator--付出了很多
- 作为deque的迭代器需要有什么功能呢？
  1. 能够指出缓冲区在哪里
  2. 能够判断是否在缓冲区的边缘
  3. 能够跳到上一个或下一个缓冲区
  4. 可以随时掌握中控器

## 2. 关联式容器

### 2.1. RB-tree

**红黑树是一种平衡二分搜寻树(平衡就是让这个二叉树高度平衡)**
有利于search和insert操作

- 它是中序遍历，所以begin指向的是最左边的，而end指向的是最右边的
- set、multiset、map、multimap都是以红黑树为底层结构的

### 2.2. set、multiset

- set和multiset的key和value是合在一起的
- set:元素的key不可以重复
- multiset:元素的key可以重复
- 无法使用迭代器改变元素值

### 2.3. map、multimap

- 它的底层支撑也是红黑树，它和set的区别就是：
  - set的value和key是同一个，它是分开的
- key不可以更改value可以更改
